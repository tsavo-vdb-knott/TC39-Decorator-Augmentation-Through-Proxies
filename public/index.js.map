{"version":3,"file":"index.js","sources":["../src/babel/legacy/patch/index.js","../src/babel/legacy/decorators/simple.js","../src/babel/legacy/examples.js"],"sourcesContent":["// https://github.com/elderapo/babel-7-property-decorator-issue/blob/fixPropertyDecorator-fix/src/index.ts\n\nexport function Property(decorator) {\n  return (\n    prototype,\n    key,\n    descriptor\n  ) => {\n    const { initializer } = descriptor;\n    decorator(prototype, key, descriptor);\n\n    const initialization = () => {\n      console.log(\"Initializing property from: \", prototype.constructor.name);\n      return initializer.apply(arguments)\n    }\n\n    prototype[key] = initializer ? initialization() : undefined;\n    return Object.getOwnPropertyDescriptor(prototype, key);\n  };\n}\n\n","import * as Patch from '../patch/index'\n\n\n/**\n * \n * LEGACY PROPERTY DECORATOR \n * \n * A simple Legacy Logger Decorator, fundamentally can be a function exported as a const,\n * an anonymous arrow function also exported as a const, or an named exported function.\n * \n * For say a property decorator the legacy spec defines the an object configuration \n * with Object.defineProperty(proto, name, descriptor); \n * \n * @param {Object} prototype - In Loose Mode - Used with Babel Legacy Decorators, this is effectively Object prototype with a Constructor.\n * This type can be used to determine if the consumer of this decorator is using a legacy API or the TC39 API\n * @param {string | Symbol} key - The string representation of the key - sometimes this is helpful to have as a Symbol \n * this can prevent descendant classes with the same property key from accessing/overriding superclass metadata\n * Also observed as being useful for key based caching purposes at runtime\n * @param { PropertyDescriptor & ThisType<any> | { get() { }; set(value) { }; enumerable: boolean; configurable: boolean; writable: boolean; value: number | object | function | any; } } descriptor - Effectively defines the configuration of the property that you are about to assign to the incoming prototype \n * @returns {void} The EXTRA Legacy Decorator Doesn't Return, it simply assigns in place through with Object.defineProperty(...) however, I believe that the @babel/plugin-proposal-decorators, with legacy: true is actually broken and does not work on properties without the middleman PathPropertyDecorator which returns a PropertyDescriptor Object \n * \n * Legacy implements a  _initializerDefineProperty(this, \"hello\", _descriptor, this);\n * \n * !! Noted: Object.defineProperty(...) does not have an initializer \n * \n */\nconst logger = (prototype, key, descriptor) => {\n\n  let { [key]: current } = prototype;\n\n  // When extended, prototype is now actually Base and the target is the extending class Base2\n  // Babel provides an initializer with the legacy spec which also lets us target the Instance of the prototype at initialization aka when new Base2 is called, it requires a scope bound function for this to be accurate.\n  Object.defineProperty(prototype, key, {\n    get: _ => (console.log(`Getting Property: ${key}`), current),\n    set: next => (console.log(`Updating Property: ${current} => ${next}...`), current = next),\n    enumerable: true,\n    configurable: true,\n  });\n}\n\nexport const Property = {\n  logger: Patch.Property(logger)\n}\n\n\nexport const Method = {\n}\n\n","import * as Simple from './decorators/simple';\nimport * as Parameters from './decorators/parameters';\n\nconst Decorators = {\n\tLegacy: {\n\t\tSimple,\n\t\tParameters\n\t}\n};\n\n\n// Base Class Declaration \nclass LegacyPropertyExample {\n\n\t// Simple Legacy Decorator without parameters\n\t@Decorators.Legacy.Simple.Property.logger\n\thello = \"world\";\n\n};\n\nclass DescendantLegacyPropertyExample extends LegacyPropertyExample {\n\t/** \n\t * \n\t * Noted: \n\t * 1. If we don't declare hello - Object.getOwnPropertyDescriptor(base, 'hello') will return undefined, thus we must use Object.getOwnPropertyDescriptor(base.__proto__, 'hello')\n\t * 2. If we declare hello - it will not inherit the default value from the Base Class (Often times in typescript we want to override a property to update strong type but still ensure it's default value from base)\n\t * 3. If we declare it with a Decorator and a Property, it will execute the decorator twice, including the initializer from babel, this is perhaps not what we want at scale\n\t * \n\t */\n\t @Decorators.Legacy.Simple.Property.logger\n\thello;\n\n};\n\nconst legacy = new DescendantLegacyPropertyExample();\n\nconsole.log(legacy);"],"names":["Property","decorator","prototype","key","descriptor","initializer","initialization","console","log","constructor","name","apply","arguments","undefined","Object","getOwnPropertyDescriptor","logger","current","defineProperty","get","_","set","next","enumerable","configurable","Patch","Method","Decorators","Legacy","Simple","Parameters","LegacyPropertyExample","DescendantLegacyPropertyExample","legacy"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEO,SAASA,UAAT,CAAkBC,SAAlB,EAA6B;AAClC,SAAO,CACLC,SADK,EAELC,GAFK,EAGLC,UAHK,KAIF;AACH,UAAM;AAAEC,MAAAA;AAAF,QAAkBD,UAAxB;AACAH,IAAAA,SAAS,CAACC,SAAD,EAAYC,GAAZ,EAAiBC,UAAjB,CAAT;;AAEA,UAAME,cAAc,GAAG,MAAM;AAC3BC,MAAAA,OAAO,CAACC,GAAR,CAAY,8BAAZ,EAA4CN,SAAS,CAACO,WAAV,CAAsBC,IAAlE;AACA,aAAOL,WAAW,CAACM,KAAZ,CAAkBC,SAAlB,CAAP;AACD,KAHD;;AAKAV,IAAAA,SAAS,CAACC,GAAD,CAAT,GAAiBE,WAAW,GAAGC,cAAc,EAAjB,GAAsBO,SAAlD;AACA,WAAOC,MAAM,CAACC,wBAAP,CAAgCb,SAAhC,EAA2CC,GAA3C,CAAP;AACD,GAfD;AAgBD;;AChBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMa,MAAM,GAAG,CAACd,SAAD,EAAYC,GAAZ,EAAiBC,UAAjB,KAAgC;AAE7C,MAAI;AAAE,KAACD,GAAD,GAAOc;AAAT,MAAqBf,SAAzB,CAF6C;AAK7C;;AACAY,EAAAA,MAAM,CAACI,cAAP,CAAsBhB,SAAtB,EAAiCC,GAAjC,EAAsC;AACpCgB,IAAAA,GAAG,EAAEC,CAAC,KAAKb,OAAO,CAACC,GAAR,CAAa,qBAAoBL,GAAI,EAArC,GAAyCc,OAA9C,CAD8B;AAEpCI,IAAAA,GAAG,EAAEC,IAAI,KAAKf,OAAO,CAACC,GAAR,CAAa,sBAAqBS,OAAQ,OAAMK,IAAK,KAArD,GAA4DL,OAAO,GAAGK,IAA3E,CAF2B;AAGpCC,IAAAA,UAAU,EAAE,IAHwB;AAIpCC,IAAAA,YAAY,EAAE;AAJsB,GAAtC;AAMD,CAZD;;AAcO,MAAMxB,QAAQ,GAAG;AACtBgB,EAAAA,MAAM,EAAES,UAAA,CAAeT,MAAf;AADc,CAAjB;AAKA,MAAMU,MAAM,GAAG,EAAf;;;;;;;;;;;;;AC1CP,MAAMC,UAAU,GAAG;AAClBC,EAAAA,MAAM,EAAE;AACPC,IAAAA,MADO;AAEPC,IAAAA;AAFO;AADU,CAAnB;;IASMC,gCAGJJ,UAAU,CAACC,MAAX,CAAkBC,MAAlB,CAAyB7B,QAAzB,CAAkCgB,2BAHpC,MAAMe,qBAAN,CAA4B;AAAA;AAAA;AAAA;;AAAA;;;;;WAInB;;;IAIHC,2CASHL,UAAU,CAACC,MAAX,CAAkBC,MAAlB,CAAyB7B,QAAzB,CAAkCgB,6BATrC,MAAMgB,+BAAN,SAA8CD,qBAA9C,CAAoE;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAcpE,MAAME,MAAM,GAAG,IAAID,+BAAJ,EAAf;AAEAzB,OAAO,CAACC,GAAR,CAAYyB,MAAZ"}